---
title: "Data visualization"
author: "Steven Moran\n"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  github_document:
      toc: true
bibliography: '../2_writing_scientific_reports/references.bib'
---

***

This report uses the [R programming language](https://cran.r-project.org/doc/FAQ/R-FAQ.html) [@R] and the following [R libraries](https://r-pkgs.org/intro.html) [@tidyverse;@knitr].

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
```


# Recap

Recall our discussion about [tabular data](https://github.com/bambooforest/IntroDataScience/tree/main/3_data#tabular-data) formats. In a table data format, every column represents a particular variable (e.g., a person's height, number of of vowels) and each row/record corresponds to a given member of the data set in question (e.g. a person, in a language). Tabular data are inherently rectangular and cannot have "ragged rows". If any row is lacking information for a particular column, a missing value (`NA`) is stored in that cell.

Tabular data come in various formats and go by various names. Table. Data set (if rectangular). Data frame. Data matrix. CSV plain text file. Spreadsheet. Etc.

For most people working with small amounts of data, the data table is the fundamental unit of organization because it is both a way of organizing data that can be processed by humans and machines. In practice, to enter, organize, modify, analyze, and store data in tabular form -- it is common for people to use spreadsheet applications. You are probably familiar for example with Excel spreadsheets. 
Many statistical software packages use similar spreadsheets and many are able to import Excel spreadsheets. R is no different.

Importantly, the input to statistical graphics or plots is typically some type of data matrix (tabular data) as input. The key is to get the data into the correct format as input to the method that will visualize the data. [Data wrangling](../4_data_wrangling/README.md) include the steps to get the data that is needed for visualization purposes. You may, however, also have to reshape the tabular data into various formats, so that you can easily feed into the method.

There are two basic presentations of tabular data:

* Wide
* Long (aka narrow)

[Wide](https://en.wikipedia.org/wiki/Wide_and_narrow_data) tabular data is unstacked and it is presented so that each different data variable is in a separate column.

| Person | Age | Weight | Height |
|----------|--------|---| 
| Bob | 32 | 168 | 180 |
| Alice	| 24 | 150 | 175 |
| Steve | 64 | 144 | 165 |

[Long](https://en.wikipedia.org/wiki/Wide_and_narrow_data) tabular data is stacked, so that one column contains all of the values and an additional column denotes the context of those values, e.g.,:

|Person	| Variable | Value |
|-------|----------|-------| 
|Bob	| Age	| 32 |
|Bob	| Weight | 168 |
|Bob	| Height | 180 |
|Alice	| Age | 24 |
|Alice	| Weight | 150 |
|Alice	| Height | 175 |
|Steve	| Age | 64 |
|Steve	| Weight | 144 |
|Steve	| Height | 165 |

The `tidyverse` works on [tidy data](https://r4ds.had.co.nz/tidy-data.html), i.e., a consistent way to organize data in R. One of the goals of the `tidyverse` suite of tools is to make an interface between data input and data output -- that is, once you have data in the tidy data format, working with the tools in the tidyverse become much simpler. In other words, to play and have fun with the tools in tidyverse, you should first get your data into the tidy format.

As shown above, the same tabular data can be formatted in different ways. (The picture is actuall more complex because data can be represented in many different ways in tables, e.g., [here](https://r4ds.had.co.nz/tidy-data.html).)

To create tidy data, there are three rules you must follow [@WickhamGrolemund2016]:

1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

So, variables in columns, observations in rows, values in cells -- in one table. This boils down to: put your data in a table (or data frame or tibble in R) and put each variable in a column.

**Which table format above is tidy?**

What are the advantages of this approach to organizing your data? Well, other than easy access to methods in the tidyverse, your data [@WickhamGrolemund2016]:

1. Is in a consistent format -- and it's easier to learn to work with one format before learning to deal with multiple

2. When variables are in columns, it is straightforward to vectorize the data -- most R functions work on vectorized data

Here's an example using the probability of death by age and sex table from the [dslabs](https://www.rdocumentation.org/packages/dslabs/versions/0.7.4/topics/death_prob) R library [@IrizarryGill2021].

```{r}
# install.packages('dslabs') # install the package if you haven't
library(dslabs)
head(death_prob)
str(death_prob)
```

Let's plot it to compare the probability of death on the y axis and age on the x axis. We plot by the factor `sex`.

```{r}
library(ggplot2)
ggplot(death_prob, aes(age, prob)) + 
  geom_line(aes(group = sex), colour = "grey50") + 
  geom_point(aes(colour = sex))
```

What does the plot tell us about the data?


# Reshaping data

Often the data you have access to will not be in tidy format.

https://github.com/datasciencelabs/2021/blob/master/03_wrangling/03_reshaping-data.Rmd


# Visualizing data


### Layers of graphics in ggplot2

* The layered Grammar of Graphics by Wickham (2009) adjusts Wilkinson's principles to R

* Each layer/component of the Grammar of Graphics has a special name in ggplot2

TODO: get image 18


### First examples (1): diamonds

* Create a new script diamonds.R and add to it the following command

* We will work with the integrated dataset diamonds

* Use the familiar functions to explore its structure

TODO: 

add https://en.wikipedia.org/wiki/Variadic_function

and explain the ...

hist(diamonds$price, …)
barplot(table(diamonds$cut), …)

```{r}
head(diamonds) # the data set is part of ggplot2
str(diamonds)
hist(diamonds$price)
barplot(table(diamonds$cut))
```

* What variables are unfamiliar to you?

We can load a description of the dataset with the `?` function.

```{r}
?diamonds # the description of the dataset
```

```{r}
str(diamonds)
```

* Which kinds of plots can we produce?

* Which kind of research questions can be answered on the basis of this dataset?

The original dataset is large

Let make the processing easier for our computer and work with a random sample of 1000 diamonds:

```{r}
diamonds <- diamonds[sample(nrow(diamonds), 1000), ] 
# a random sample of 1000 objects
```

The basic ggplot2 function has the following form:

```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()
```

Can you guess what the function ggplot() does?

What about geom_point()?

```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()
```

The symbol + should always be at the end of each line if there is something to follow.


```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()
```

- With ggplot2, you begin a plot with the function ggplot().
- ggplot() creates a coordinate system that you can add layers to. 
- The first argument of ggplot() is the dataset to use in the graph. 
- So ggplot(data = diamonds) creates an empty graph
- It's not very interesting so I'm not going to show it here.

A simple plot with ggplot2 needs

- data (a data frame or tibble!), 
- aesthetic (mapping to variables), 
- geometry (e.g. dots, lines, boxes)

TODO: insert image slide 26

### Aesthetics

- _aesthetic_ comes from Greek _aisthētikos_ < _aisthēta_ ‘perceptible things' < _aisthesthai_ ‘perceive'
- In the `ggplot` sense this old usage is meant: 
  - aesthetics stand for principles for **relating sensory attributes (color, shape, sound, etc.) to abstractions**

```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()
```

- Which aesthetic attributes are sued here?
- What perceivable part of the plot do they correspond to?

- `geom_()`:  geom is short for **geometric** object
- It describes the type of object that is used to display the data
- `geom_point()` produces a _______


### Combining geoms

Add to your ggplot() function another geom()

```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth(method = 'lm')
```

- It can be hard to view trends with just points alone. 
- Many times we wish to add a **smoothing** line (**smoother**) in order to see what the trends look like
- This can be especially helpful when trying to understand regressions

- aka local regression or moving regression
- Most common methods, initially developed for scatterplot smoothing, are
  - LOESS (locally estimated scatterplot smoothing) and
  - LOWESS (locally weighted scatterplot smoothing), both pronounced /ˈloʊɛs/
  
Note that the `geom_smooth()` function adds confidence bands on the smoother. 

We can remove these by adding `se=FALSE` inside the `geom_smooth()` function  

- standard error (se)

Combining geoms example

a) Add to your ggplot() function another geom

```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point() +
geom_smooth()
```
 
It can be hard to view trends with just points alone. Many times we wish to add a smoothing line (smoother) in order to see what the trends look like.
This can be especially helpful when trying to understand regressions.

b) Step 2: copy the first command and modify it: remove the dots and produce a plot with only the smoother of the dots

c) Step 3: copy the first command and modify the representation of the dots:

```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point(col = "red", alpha = 0.3)
```

Can you guess what alpha = 0.3 does? Try out other alpha values.

alpha controls the transparency of the points: 1 = opaque, less than 1 semi-transparent

Some more examples

```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point() +
geom_smooth()
```

```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point() +
geom_smooth(se = FALSE)
```

```{r}
# only the smoother
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_smooth()
```

```{r}
# alpha-adjustment
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point(alpha = 0.3)
```

## The basics of the grammar of graphics

- If you plan to create multiple plots on the basis of the same variables, it's convenient to first save the basic plot (with `aes()`)
- Different geoms can be then added to this basic plot in further commands
- And if desired you can even add further aesthetics later
- E.g. in the function `geom_point()`

```{r}
diamonds_plot <- ggplot(data = diamonds, aes(x = carat, y = price))
diamonds_plot + geom_point()
diamonds_plot + geom_point(aes(col = clarity))
```

```{r}
diamonds_small <- diamonds %>% head(n=1000)
diamonds_plot <- ggplot(data = diamonds_small, aes(x = carat, y = price))
summary(diamonds_plot)
```

```{r}
diamonds_plot + geom_point(aes(col = clarity))
```

It's convenient to work with the previously save basic plot.

A complete dataset of over 50 000 diamonds:

```{r}
dplot <- ggplot(diamonds, aes(x = carat, y = price))
dplot + geom_point()
dplot + geom_point(size = 0.5)
dplot + geom_point(size = 0.3, alpha = 1/10)
dplot + geom_point(size = 0.5, alpha = 1/50)
dplot + geom_point(size = 0.5, alpha = 1/50, shape = 1)
```

### Overplotting: position adjustment

Another solution for the overplotting issue: position adjustment slightly modifies the position of the plotted elements, specifically in the case of discrete variables.

```{r}
#  no need to specify the default!
ggplot(diamonds, aes(x = depth, y = carat, col = cut)) + geom_point(position = "identity")
```


```{r}
Adjustment <- c('identity', 'dodge', 'stack', 'fill', 'jitter', 'jitterdodge')
Description <- c('default, don’t adjust position', 'dodge overlaps to the side', 'stack overlapping objects on top of one another', 'stack overlapping objects and standardise to equal height', 'jitter points to avoid overplotting', 'or `geom_jitter()`')
df <- data.frame(Adjustment, Description)
```

```{r}
knitr::kable(df)
```

### The basics of the grammar of graphics

```{r}
diamonds_plot <- ggplot(data = diamonds_small,
                     aes(x = carat, y = price))
```

Before plotting the second command, can you guess what it will produce?

```{r}
diamonds_plot + geom_point(alpha = 0.2) + geom_smooth(se = FALSE)
```

```{r}
diamonds_plot + geom_point(alpha = 0.2) + geom_smooth(aes(col = clarity), se = FALSE)
```

```{r}
diamonds_plot + geom_point(aes(col = clarity), alpha = 0.2) + geom_smooth(se = FALSE)
```

Note: the new `aes` introduced in `geom_smooth()` applies only to the smoother and produces multiple local regression lines (one for each type of clarity).

### More plots

- Produce a similar plot by combining the familiar geoms and aesthetics
- Can the overplotting problem be improved further?

```{r}
ggplot(diamonds, aes(x = depth, y = table)) +
        geom_point(alpha = 0.2, size = 0.5, col = "red") +
        geom_smooth(col = "red")
```

```{r}
ggplot(diamonds, aes(x = depth, y = table)) + geom_jitter(alpha = 0.2, size = 0.5, col = "red") + geom_smooth(col = "blue")
```

### Aesthetics

What aesthetic attributes of a plot can we perceive?

TODO: insert image on page 48

```{r, eval = FALSE}
ggplot(diamonds, aes(x = depth, y = table)) + geom_point(alpha = 0.2, col = "dodgerblue") +
geom_smooth(col = "red2")
```

- depth is mapped to the horizontal position (x axis),
  - table is mapped to the vertical position (y axis)
- The size, color and transparency of the dots are not mapped to any variable 
- The have constant values set by the user

Setting

- Mapping is done within the function `aes()`
- Setting of constant values: within the respective geom() functions

```{r, eval = FALSE}
ggplot(diamonds, aes(x = depth, y = table, col = cut, alpha = price)) + geom_points() +
geom_smooth(col = "red2")
```

Common aesthetic attributes:
 
- x, y
- size
- fill
- label
- line type 
- shape
- color (color of a dot or a border)
- alpha

- Different aesthetics are available for different types of data 
  - color and form: good for nominal/categorical variables 
  - size: good for continuous variables
  
## Geoms

todo: add image from page 52

### Geometries

Based on Teutonico (2015) (todo)

- Geoms determine the type of the plot
- Similar function `geom_x`
- E.g. One can combine various geoms in one plot

```{r}
ggplot(diamonds_small, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth()
```

```{r}
geom_functions <- c(
  'geom_bar',
  'geom_boxplot',
  'geom_density',
  'geom_histogram',
  'geom_line',
  'geom_point',
  'geom_jitter',
  'geom_smooth',
  'geom_text',
  'geom_tile')
Description <- c(
  'bars with bases on the x axis',
  'a box-and-whiskers plot',
  'a smooth density estimate calculated by `stat_density`',
  'a histogram',
  'connects observations ordered by the x value',
  'represents observations as points, as in a scatterplot',
  'points jittered (usually to reduce overplovng)',
  'adds a smoothed conditional mean',
  'adds textual annotations',
  'a tile plane with rectangles')
df <- data.frame(geom_functions, Description)
```

```{r}
knitr::kable(df)
```

### geom_boxplot

- Which pare of variables are suitable for `geom_boxplot()`?
- `geom_boxplot()` needs a y = and a grouping variable `x =`
- In addition to `x =`, one can also the aesthetic attributes `col =` or `fill =` to specify further mapping to a categorical variable
- Pick a pair of suitable variables and produce a nice boxplot

```{r}
ggplot(diamonds, aes(y = price, x = color)) +
        geom_boxplot()
```

```{r}
ggplot(diamonds, aes(y = price, fill = color)) + geom_boxplot()
```

```{r}
ggplot(diamonds, aes(x = clarity, y= price, fill = clarity)) +
  geom_boxplot() +
  geom_jitter(alpha = .18, size = 1)
```

todo: insert image / table from page 59 and 60

### Geoms: geom_tile (heat maps)

```{r}
# todo: load athletes
athletes <- read_csv('../4_data_wrangling/datasets/athletes.csv')
```

```{r}
ggplot(athletes, aes(x = gender, y = sport)) + geom_tile(aes(fill = age))
```

### Facetten / facets

- You can produce multiple plots in one go split by a variable ➜ faceting
- "This is a powerful tool when investing whether patterns hold across all conditions." (Wickham 2009: 38)
- Two options: `facet_grid` and `facet_wrap`
  - `facet_grid` a 2D projection with row and columns
  - `facet_wrap` a 1D Projection: a band of plots which are wrapped as desired
  
todo: insert image from page 64


#### facet_grid

- Basic code: x ~ y (x and y two categorical variables) ➜ a set of plots for various combinations of x and y
- When you have only one categorical variable: x ~. or . ~ x
 
```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point(alpha = 0.3, size = 0.5) + facet_grid(.~cut)
ggplot(diamonds, aes(x = carat, y = price)) + geom_point(alpha = 0.3, size = 0.5) + facet_grid(cut~.)
```

todo: insert table from page 66

todo: generate image from page 67

todo: generate image from page 68

todo: note we are skipping german slides and the Gavin case study


## qplot

### Faceting with qplot()

- You can use faceting to create multiple plots by creating a subplot for each level of a categorical variable
- The general code for faceting: `facets=a~b`
- a and b represent two categorical variables for which data is split
  - a grid with subplots for each combination of the a and b variables.
- However, often you are interested in faceting only relative to one variable: `facets = a~.` (`.` means there is no second faceting variable)

```{r, eval=FALSE}
qplot(x, y, data, color, shape, size, facets, geom, stat)
```

### Faceting with qplot(): an example

- The general code for faceting: `facets = a ~ b`

```{r}
qplot(height, weight, data = athletes, facets = gender~sport)
```
Dataset without Figure Skating:

```{r}
data = athletes[athletes$sport != "Figure Skating", ]
```

- How to change the faceting orientation
  - If you need to change the panel orientation, change the order of the variables:
    - `facets = a ~ b`: create one row for each value of a and one column for each value of b
    - `facets = b ~ a`: will do it the other way around
    - Also: `facets = a ~ .` vs. `facets = . ~ a`

### Faceting with qplot(): exercise 3

Produce a plot of weight and height for the two genders separately similar to this one:

todo: insert image from page 80 (write code that recreates it)

Produce a plot of weight and height for the two genders separately similar to this one:

todo: insert image from page 81 (write code that recreates it)

```{r, eval=FALSE}
qplot(height, weight, data = athletes,
facets = .~gender, color = gender, size = I(0.7))
```

<details>
  <summary>Click for Answer</summary>
    {r, echo=FALSE, eval=TRUE}
    hist(1:10)
    
</details>


### Histograms with qplot()

```{r, eval=FALSE}
qplot(x, y, data, color, shape, size, facets, geom, stat)
```

- The geometric attribute used to produce histograms is defined simply by specifying ,`geom="histogram"`, e.g.

```{r}
qplot(age, data = athletes, geom = "histogram")
```

- Modify this basic histogram to produce two subplots for both genders and adjust the colors respectively
- Use the fill argument which defines the filling of the graphical elements

```{r}
qplot(age, data = athletes, facets = .~gender, color = gender, geom = "histogram")
```

```{r}
qplot(age, data = athletes, facets = .~gender, color = gender, fill = gender, geom = "histogram")
```

- We can also color the two genders differently within the same histogram, e.g.

```{r}
qplot(age, data = athletes, geom = "histogram", color = gender)
```

- Modify this basic histogram to produce two subplots for both genders and adjust the colors respectively
- Use the `fill` argument which defines the filling of the graphical elements

### Density plots with qplot(): exercise 4

- Another useful way of representing distributions: the kernel density function (an approximation of the distribution of the data as a
continuous function instead of different bins): `geom="density"`

- The default plot has quite strong colors
  - add some transparency with the alpha argument: degree of transparency between 0 (transparent) and 1 (opaque)

- This is a purely aesthetic parameter:
  - we are not mapping some data, but simply assigning a value of transparency: use the `I()` function

- Produce this density plot:

todo: insert code producing image on page 85


## Plots with ggplot()


### ggplot2 and The Grammar of Graphics

- The `ggplot2` package is an implementation of the ideas presented in the book [The Grammar of Graphics](https://books.google.ch/books?id=ZiwLCAAAQBAJ&lpg=PR3&dq=the%20grammar%20of%20graphics&pg=PR5#v=onepage&q=the%20grammar%20of%20graphics&f=false) by [Leland Wilkinson](https://en.wikipedia.org/wiki/Leland_Wilkinson).

- The goal of the book: define a set of general unifying principles for the visualization of data
- Basic idea:
  - instead of many different functions targeting the realization of one specific type of graph (`boxplot()`, `hist()`, etc.)
  - `ggplot2` provides a smaller set of functions defining different components of a graph, which can be combined to generate a large variety of plots
- Designed to help in separating and identifying each step of the charting process, helping you to better decide upon the best way to visualize data


### Components of the grammar of graphics in ggplot2 (Wickham (2009))

- The layered grammar of graphics (Wickham, 2009) builds on Wilkinson’s grammar

- It focuses on the primacy of layers and adapts it for embedding within R.

- A statistical graphic according to the layered grammar of graphics is a mapping from data to
  - aesthetic attributes (colour, shape, size) of 
  - geometric objects (points, lines, bars)

- The plot may also contain **statistical transformations** of the data and is drawn on a specific **coordinate** system. **Faceting** can be used to generate the same plot for different subsets of the dataset.

- It is the combination of these independent components that make up a graphic.

- Each component of the grammar of graphics in ggplot2 has a specific name

todo: insert graphic from page 89


### Revision: qplot() and Tooth Growth (Teutonico (2015))

- A new small built-in dataset: ToothGrowth

- On the effect of vitamin C on tooth growth in guinea pigs

  - The response variables len is the length of odontoblasts (cells responsible for tooth growth) in 60 guinea pigs.

  - Each animal received one of three dose levels of vitamin C (0.5, 1, and 2 mg/day)

  - By one of two delivery methods (sup): 
    - orange juice (OJ) or
    - ascorbic acid/vitamin C (VC)

- For revision: create a plot with `qplot()` showing how the dose of vitamin C affects the growth of teeth and whether it depend on the delivery method

```{r}
data("ToothGrowth")
?ToothGrowth
head(ToothGrowth)
```

```{r}
qplot(dose, len, data=ToothGrowth, geom="point", col = supp)
```

```{r}
qplot(dose, len,data=ToothGrowth, geom="point", facets=.~supp, col = supp)
```

It looks like the subgroup where orange juice was administered has higher teeth growth compared to the subgroup where ascorbic acid was administered


### What precisely is a scatterplot? Mapping aesthetics to data (Teutonico (2015))

- A scatterplot represents each observation as a point (•),
  - positioned according to the value of two variables,
  - additionally each point has a size, a colour and a shape

- These attributes (aesthetics) are the properties that can be perceived on the graphic

- Each aesthetic can be mapped to a variable, or set to a constant value

- Here dose is mapped to horizontal position / x-axis, len to vertical position / y-axis and supp to colour

- Size and shape are not mapped to variables, but remain at their (constant) default values

todo: insert image from page 92


### Creating a plot layer by layer with ggplot()

- Let’s create the same plot with `ggplot()` by adding one layer after another

- First, create the basic plot object containing the data (ToothGrowth) and aesthetic mapping

```{r}
myPlot <-ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp))
```

- Aesthetic mapping is provided using the `aes()` function within the body of the `ggplot()` function

** Aesthetic mapping to x and y** 

Keep in mind that the mapping to the x and y variables in the plot is a part of aesthetic mapping and must be included in the `aes()` functions.

```{r}
myPlot <-ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp))
```

Try to call the object myPlot in an empty window!

```{r}
myPlot
```

- `myPlot` contains the basic information of the plot, BUT it doesn’t produce any output because it does not yet contain any
`geom` assignment ⇾ no actual visualization attribute assigned to the plot

- The `myPlot` object consists of a component named data and other components containing information about the plot.

Check the plot details using `summary()`

```{r}
summary(myPlot)
```

- In this way we can keep track of exactly which data was used in the plot and how the mapping was realized

Now we’ll add a layer to our basic plot object and create a basic plot.

A basic plot can be realized using

- data (a dataframe!),
- aesthetic mapping, and
- geometry (missing)

```{r}
myPlot <-ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp))
```

In the `ggplot()` function, additional layers are added using the + operator followed by the function defining the layer to be added

For a scatterplot with points:

```{r}
myPlot <-ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp)) 
myPlot + geom_point()
```


### How to separate code in multiple lines

```{r}
# myPlot <-ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp)) myPlot + geom_point()
```

You can also put all code together into one command:

```{r}
ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp)) + geom_point()
```

- With both options, you will obtain the same results

- Using assignment to objects (here `myPlot`) can be useful if you have a long series of plots using the same data.

- In this case, you would have shorter and cleaner code that uses a previously created plot object


- When you use the `+` operator to add plot elements, you may end up with quite long lines of code which would benefit some organizations.
- A common way to structure code: divide it into multiple lines
- Remember: the `+` operator should be always on the right-hand side of the previous line:

```{r}
myPlot + geom_point()
```

A correct division:

```{r}
myPlot + 
  geom_point()
```

An incorrect division:

```{r}
myPlot + geom_point()
```

todo: link to section on lintr and best programming practices

Also, in this case, we can create a new object containing the final plot

```{r}
finalPlot <- myPlot + geom_point()
finalPlot
```

Use the summary() function to see the object’s content:

```{r}
summary(finalPlot)
```


### Geometry (Teutonico (2015))

- The geometry attributes define the actual type of plot to be applied to the data provided in the `ggplot()` function

- These attributes are provided using functions with the general form `geom_x`

- Here x can be replaced by the specified geometry, e.g. histogram or point

- It is also possible to combine different geometries by combining different functions with the + operator, e.g. 
  - geom_point() + geom_smooth()

todo: insert table geometry from page 101


### The aesthetic attributes and geom function (Teutonico (2015))

- The aesthetic attributes that you can map to variables depend on the geom function used
- the x and/or y arguments are mandatory
- you can use the optional arguments to personalize your plot and to shape it in the best way to describe the data you have.
  - e.g. the fill argument we used to color the internal part of the
  - histograms or the alpha argument we used for transparency
- Use the table Mandatory and optional arguments of common geom functions as a reference to quickly search for such arguments and to check the possible alternatives


### Mandatory and optional arguments of geom functions

todo insert table from 103


### The aesthetic attributes and geom function: exercise 1

- Take the dataset athletes

- Produce the following plots with the function `ggplot()` using this template:

```{r, eval=FALSE}
ggplot(data=..., aes(x=..., y=...)) + geom_...()
```

- (a) a barplot of the frequency of the two genders
- (b) a histogram for the variable height
- (c) a scatterplot for the variables height and weight
- (d) a boxplot for the variables gender and weight

todo: make into an exercise with images


### Aesthetic mappings vs. setting (Wickham (2009))

- Other aesthetic attributes are alpha, color, fill, linetype, shape, size, weight

```{r, eval=FALSE}
ggplot(data=..., aes(x=..., y=..., color = ..., size = ...)) + geom_...()
```

Each aesthetic can be **mapped** to a variable, or **set** to a constant value

```{r}
ggplot(data=ToothGrowth, aes(x=dose, y=len, col=supp))
```

```{r}
ggplot(data=ToothGrowth, aes(x=dose, y=len, col="red"))
```

- With `qplot()`, you could do the same thing by putting the value inside of `I()`, e.g., `colour = I("darkblue")`


### The aesthetic attributes and geom function: exercise 2

Other aesthetic attributes are alpha, color, fill, linetype, shape, size, weight

```{r, eval=FALSE}
ggplot(data=..., aes(x=..., y=..., color = ..., size = ...)) + geom_...()
```

Take the dataset athletes

Reproduce with ggplot() the plot of the athletes doing luge we created earlier with qplot():

```{r}
qplot(height, weight,
data = athletes[athletes$sport == "Luge", ], size = age,
color = gender)
```

Other aesthetic attributes are alpha, color, fill, linetype, shape, size, weight

```{r, eval=FALSE}
ggplot(data=..., aes(x=..., y=..., color = ..., size = ...)) + geom_...()
```

Take the dataset athletes

Reproduce with `ggplot()` the plot of the athletes doing luge we created earlier with qplot():

```{r}
ggplot(data = athletes[athletes$sport == "Luge", ],
aes(x = height, y = weight, size = age, color = gender)) +
geom_point()
```


# References
